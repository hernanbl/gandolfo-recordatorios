import asyncio
import re
import traceback
from datetime import datetime, date, timedelta
from routes.bot import validar_fecha_reserva, verificar_capacidad_disponible
from services.twilio.messaging import send_whatsapp_message
from utils.session_manager import save_session
from db.supabase_client import supabase_client
from services.twilio.intelligent_parser import intelligent_parser
import logging
import locale

logger = logging.getLogger(__name__)

# Mapeo de d√≠as de la semana en espa√±ol
DIAS_SEMANA = {
    'Monday': 'lunes',
    'Tuesday': 'martes', 
    'Wednesday': 'mi√©rcoles',
    'Thursday': 'jueves',
    'Friday': 'viernes',
    'Saturday': 's√°bado',
    'Sunday': 'domingo'
}

# Mapeo de meses en espa√±ol
MESES = {
    'January': 'enero',
    'February': 'febrero',
    'March': 'marzo',
    'April': 'abril',
    'May': 'mayo',
    'June': 'junio',
    'July': 'julio',
    'August': 'agosto',
    'September': 'septiembre',
    'October': 'octubre',
    'November': 'noviembre',
    'December': 'diciembre'
}

def format_date_spanish(fecha_obj):
    """Formatea una fecha en espa√±ol"""
    try:
        # Obtener d√≠a de la semana en ingl√©s
        dia_semana_en = fecha_obj.strftime("%A")
        # Obtener mes en ingl√©s
        mes_en = fecha_obj.strftime("%B")
        # Obtener d√≠a y a√±o
        dia = fecha_obj.strftime("%d")
        a√±o = fecha_obj.strftime("%Y")
        
        # Traducir al espa√±ol
        dia_semana_es = DIAS_SEMANA.get(dia_semana_en, dia_semana_en.lower())
        mes_es = MESES.get(mes_en, mes_en.lower())
        
        return f"{dia_semana_es} {dia} de {mes_es} de {a√±o}"
    except Exception as e:
        logger.error(f"Error formateando fecha en espa√±ol: {str(e)}")
        return fecha_obj.strftime("%d/%m/%Y")

# Estados del flujo de reserva
RESERVATION_STATES = {
    'INICIO': 'inicio',
    'ESPERANDO_FECHA': 'esperando_fecha', 
    'ESPERANDO_PERSONAS': 'esperando_personas',
    'ESPERANDO_CONFIRMACION_INICIAL': 'esperando_confirmacion_inicial',  # Nuevo estado
    'ESPERANDO_NOMBRE': 'esperando_nombre',
    'ESPERANDO_TELEFONO': 'esperando_telefono',
    'ESPERANDO_EMAIL': 'esperando_email',
    'ESPERANDO_CONFIRMACION': 'esperando_confirmacion',
    'COMPLETADA': 'completada'
}

def handle_reservation_flow(from_number, message, restaurant_config, session, mensaje_normalizado):
    """
    Maneja el flujo completo de reservas para WhatsApp
    """
    try:
        restaurant_name = restaurant_config.get('nombre', 'el restaurante')
        reservation_state = session.get('reservation_state', RESERVATION_STATES['INICIO'])
        reservation_data = session.get('reservation_data', {})
        
        # LOGGING CR√çTICO PARA DEBUG
        logger.info(f"üîÑ FLUJO RESERVA: {from_number} | Estado: {reservation_state} | Mensaje: '{message}'")
        logger.info(f"üìä DATOS ACTUALES: {reservation_data}")
        
        # INICIO DEL FLUJO DE RESERVA - CON PARSING INTELIGENTE
        if reservation_state == RESERVATION_STATES['INICIO']:
            logger.info(f"üöÄ INICIANDO FLUJO para {from_number}")
            return start_reservation_flow_intelligent(from_number, message, restaurant_config, session)
        
        # PROCESANDO FECHA
        elif reservation_state == RESERVATION_STATES['ESPERANDO_FECHA']:
            logger.info(f"üìÖ PROCESANDO FECHA para {from_number}")
            return asyncio.run(process_date_input(from_number, message, restaurant_config, session, reservation_data))
        
        # PROCESANDO CANTIDAD DE PERSONAS
        elif reservation_state == RESERVATION_STATES['ESPERANDO_PERSONAS']:
            logger.info(f"üë• PROCESANDO PERSONAS para {from_number}")
            return asyncio.run(process_persons_input(from_number, message, restaurant_config, session, reservation_data))
        
        # PROCESANDO NOMBRE
        elif reservation_state == RESERVATION_STATES['ESPERANDO_NOMBRE']:
            logger.info(f"üë§ PROCESANDO NOMBRE para {from_number}")
            return process_name_input(from_number, message, restaurant_config, session, reservation_data)
        
        # PROCESANDO TEL√âFONO
        elif reservation_state == RESERVATION_STATES['ESPERANDO_TELEFONO']:
            logger.info(f"üì± PROCESANDO TEL√âFONO para {from_number}")
            return process_phone_input(from_number, message, restaurant_config, session, reservation_data)
        
        # CONFIRMACI√ìN INICIAL - Despu√©s del parsing inteligente
        elif reservation_state == RESERVATION_STATES['ESPERANDO_CONFIRMACION_INICIAL']:
            logger.info(f"ü§ñ PROCESANDO CONFIRMACI√ìN INICIAL para {from_number}")
            return process_initial_confirmation(from_number, message, restaurant_config, session, reservation_data)
        
        # PROCESANDO EMAIL - CR√çTICO
        elif reservation_state == RESERVATION_STATES['ESPERANDO_EMAIL']:
            logger.info(f"üìß PROCESANDO EMAIL para {from_number} - FLUJO CR√çTICO")
            return process_email_input(from_number, message, restaurant_config, session, reservation_data)
        
        # CONFIRMACI√ìN FINAL
        elif reservation_state == RESERVATION_STATES['ESPERANDO_CONFIRMACION']:
            logger.info(f"‚úÖ PROCESANDO CONFIRMACI√ìN para {from_number}")
            return asyncio.run(process_confirmation(from_number, message, restaurant_config, session, reservation_data))
        
        else:
            logger.warning(f"‚ö†Ô∏è ESTADO NO RECONOCIDO: {reservation_state} para {from_number}")
            return start_reservation_flow(from_number, restaurant_config, session)
            
    except Exception as e:
        logger.error(f"üí• ERROR EN FLUJO DE RESERVA para {from_number}: {str(e)}")
        logger.error(f"Traceback: {traceback.format_exc()}")
        return reset_reservation_flow(from_number, restaurant_config, session, "Hubo un error. Iniciemos el proceso de reserva nuevamente.")

def start_reservation_flow(from_number, restaurant_config, session):
    """Inicia el flujo de reserva"""
    restaurant_name = restaurant_config.get('nombre', 'el restaurante')
    restaurant_id = restaurant_config.get('id')
    
    # Actualizar estado de la sesi√≥n
    session['reservation_state'] = RESERVATION_STATES['ESPERANDO_FECHA']
    session['reservation_data'] = {}
    
    # Guardar sesi√≥n
    save_session(from_number, session, restaurant_id)
    
    mensaje = f"¬°Perfecto! Te ayudo a hacer una reserva en {restaurant_name}. üìÖ\n\n"
    mensaje += "Por favor, dime para qu√© **fecha** quieres hacer la reserva.\n\n"
    mensaje += "Puedes escribir:\n"
    mensaje += "‚Ä¢ **Hoy** o **ma√±ana**\n"
    mensaje += "‚Ä¢ **DD/MM/YYYY** (ej: 25/05/2025)\n"
    mensaje += "‚Ä¢ **25 de mayo** o **viernes**"
    
    send_whatsapp_message(from_number, mensaje, restaurant_config)
    return None  # No enviar mensaje de debug al cliente

def start_reservation_flow_intelligent(from_number, message, restaurant_config, session):
    """Inicia el flujo de reserva con parsing inteligente del mensaje completo"""
    restaurant_name = restaurant_config.get('nombre', 'el restaurante')
    restaurant_id = restaurant_config.get('id')
    
    logger.info(f"üîç INTELLIGENT START: Analizando mensaje inicial: '{message}'")
    
    try:
        # Usar parser inteligente para extraer informaci√≥n completa
        parsed_data = intelligent_parser.parse_complete_message(message)
        
        logger.info(f"üìä PARSING RESULT: {parsed_data}")
        
        # Inicializar datos de reserva
        reservation_data = {}
        next_state = None
        
        # Procesar la informaci√≥n extra√≠da
        if parsed_data['confidence'] >= 0.3:  # Si encontr√≥ algo √∫til
            if parsed_data['fecha']:
                reservation_data['fecha'] = parsed_data['fecha']
                logger.info(f"‚úÖ Fecha extra√≠da: {parsed_data['fecha']}")
            
            if parsed_data['hora']:
                reservation_data['hora'] = parsed_data['hora']
                logger.info(f"‚úÖ Hora extra√≠da: {parsed_data['hora']}")
                
            if parsed_data['personas']:
                reservation_data['personas'] = parsed_data['personas']
                logger.info(f"‚úÖ Personas extra√≠das: {parsed_data['personas']}")
        
        # Determinar pr√≥ximo estado basado en qu√© informaci√≥n falta
        if not reservation_data.get('fecha'):
            next_state = RESERVATION_STATES['ESPERANDO_FECHA']
        elif not reservation_data.get('personas'):
            next_state = RESERVATION_STATES['ESPERANDO_PERSONAS']
        else:
            # Tenemos fecha y personas, pero necesitamos confirmaci√≥n antes de continuar
            if parsed_data['confidence'] >= 0.7 and len(parsed_data['extracted_info']) >= 2:
                # Informaci√≥n suficiente, solicitar confirmaci√≥n inicial
                next_state = RESERVATION_STATES['ESPERANDO_CONFIRMACION_INICIAL']
            else:
                # Informaci√≥n insuficiente, pedir m√°s datos
                next_state = RESERVATION_STATES['ESPERANDO_FECHA']
        
        # Actualizar sesi√≥n
        session['reservation_state'] = next_state
        session['reservation_data'] = reservation_data
        save_session(from_number, session, restaurant_id)
        
        # Generar mensaje de respuesta inteligente
        mensaje = intelligent_parser.generate_confirmation_message(parsed_data, restaurant_name)
        
        send_whatsapp_message(from_number, mensaje, restaurant_config)
        logger.info(f"üöÄ INTELLIGENT START COMPLETE: Pr√≥ximo estado: {next_state}")
        
        return None  # No enviar mensaje de debug al cliente
        
    except Exception as e:
        logger.error(f"‚ùå ERROR in intelligent parsing: {str(e)}")
        logger.error(f"Traceback: {traceback.format_exc()}")
        
        # Fallback al flujo tradicional si el parser inteligente falla
        logger.info("üîÑ Fallback: usando flujo de reserva tradicional")
        return start_reservation_flow(from_number, restaurant_config, session)

async def process_date_input(from_number, message, restaurant_config, session, reservation_data):
    """Procesa la entrada de fecha con parsing inteligente mejorado"""
    restaurant_name = restaurant_config.get('nombre', 'el restaurante')
    
    logger.info(f"üîç DATE INPUT: Procesando fecha: '{message}'")
    
    fecha_str = None
    
    try:
        # Usar parser inteligente para extraer fecha del mensaje
        parsed_data = intelligent_parser.parse_complete_message(message)
        
        # Si el parser inteligente encontr√≥ una fecha, usarla
        if parsed_data['fecha']:
            fecha_str = parsed_data['fecha']
            logger.info(f"‚úÖ Fecha extra√≠da por parser inteligente: {fecha_str}")
        else:
            # Fallback al m√©todo manual existente
            message_lower = message.lower()
            hoy = date.today()
            
            if any(word in message_lower for word in ['hoy', 'today']):
                fecha_str = hoy.strftime("%d/%m/%Y")
            elif any(word in message_lower for word in ['ma√±ana', 'tomorrow']):
                tomorrow = hoy + timedelta(days=1)
                fecha_str = tomorrow.strftime("%d/%m/%Y")
            else:
                # Buscar patr√≥n de fecha tradicional
                date_pattern = r'\b(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})\b'
                match = re.search(date_pattern, message)
                if match:
                    day, month, year = match.groups()
                    fecha_str = f"{day.zfill(2)}/{month.zfill(2)}/{year}"
                    logger.info(f"‚úÖ Fecha extra√≠da por regex: {fecha_str}")
        
        if not fecha_str:
            mensaje = f"No pude entender la fecha. üìÖ\n\n"
            mensaje += "Por favor, dime la fecha de otra manera:\n"
            mensaje += "‚Ä¢ **Hoy** o **ma√±ana**\n"
            mensaje += "‚Ä¢ **DD/MM/YYYY** (ej: 25/05/2025)\n"
            mensaje += "‚Ä¢ **25 de mayo**"
            send_whatsapp_message(from_number, mensaje, restaurant_config)
            return None
        
        # Validar fecha
        fecha_valida, mensaje_error = await validar_fecha_reserva(fecha_str)
        
        if not fecha_valida:
            send_whatsapp_message(from_number, mensaje_error, restaurant_config)
            return None  # No enviar mensaje de debug al cliente
        
        # Guardar fecha y pasar al siguiente paso
        reservation_data['fecha'] = fecha_str
        session['reservation_data'] = reservation_data
        session['reservation_state'] = RESERVATION_STATES['ESPERANDO_PERSONAS']
        
        # Guardar sesi√≥n
        restaurant_id = restaurant_config.get('id')
        save_session(from_number, session, restaurant_id)
        
        try:
            fecha_obj = datetime.strptime(fecha_str, "%d/%m/%Y")
            fecha_formateada = format_date_spanish(fecha_obj)
        except:
            fecha_formateada = fecha_str
        
        mensaje = f"¬°Excelente! Reserva para el {fecha_formateada}. üë•\n\n"
        mensaje += "¬øPara cu√°ntas **personas** ser√° la reserva?\n\n"
        mensaje += "Ejemplo: 4 personas"
        
        send_whatsapp_message(from_number, mensaje, restaurant_config)
        return None  # No enviar mensaje de debug al cliente
        
    except Exception as e:
        logger.error(f"‚ùå ERROR in process_date_input: {str(e)}")
        logger.error(f"Traceback: {traceback.format_exc()}")
        
        # Fallback con mensaje gen√©rico
        mensaje = f"Hubo un problema procesando la fecha. üìÖ\n\n"
        mensaje += "Por favor, intenta escribir la fecha nuevamente:\n"
        mensaje += "‚Ä¢ **Hoy** o **ma√±ana**\n"
        mensaje += "‚Ä¢ **DD/MM/YYYY** (ej: 25/05/2025)"
        
        send_whatsapp_message(from_number, mensaje, restaurant_config)
        return None

async def interpret_date_with_ai(message):
    """Usa IA para interpretar fechas en lenguaje natural"""
    try:
        from services.ai.deepseek_service import interpret_natural_date
        return await interpret_natural_date(message)
    except Exception as e:
        logger.error(f"Error interpretando fecha con IA: {str(e)}")
        return None

async def process_persons_input(from_number, message, restaurant_config, session, reservation_data):
    """Procesa la entrada de cantidad de personas con parsing inteligente"""
    restaurant_name = restaurant_config.get('nombre', 'el restaurante')
    
    logger.info(f"üîç PERSONS INPUT: Procesando personas: '{message}'")
    
    personas = None
    
    try:
        # Usar parser inteligente primero
        parsed_data = intelligent_parser.parse_complete_message(message)
        
        if parsed_data['personas']:
            personas = parsed_data['personas']
            logger.info(f"‚úÖ Personas extra√≠das por parser inteligente: {personas}")
        else:
            # Fallback al m√©todo manual existente
            numbers = re.findall(r'\b(\d+)\b', message)
            
            if numbers:
                try:
                    personas = int(numbers[0])
                    logger.info(f"‚úÖ Personas extra√≠das por regex: {personas}")
                except ValueError:
                    pass
        
        if not personas:
            mensaje = "No pude identificar la cantidad de personas. üë•\n\n"
            mensaje += "Por favor, dime un n√∫mero.\nEjemplo: 4 personas"
            send_whatsapp_message(from_number, mensaje, restaurant_config)
            return None  # No enviar mensaje de debug al cliente
        
        if personas <= 0:
            mensaje = "La cantidad de personas debe ser mayor a 0. üë•\n\n"
            mensaje += "¬øPara cu√°ntas personas ser√° la reserva?"
            send_whatsapp_message(from_number, mensaje, restaurant_config)
            return None  # No enviar mensaje de debug al cliente
            
        if personas > 20:  # L√≠mite razonable
            mensaje = f"Para reservas de m√°s de 20 personas, por favor contacta directamente con {restaurant_name}.\n\n"
            mensaje += "¬øPodr√≠as indicar una cantidad menor o contactarnos por tel√©fono?"
            send_whatsapp_message(from_number, mensaje, restaurant_config)
            return None  # No enviar mensaje de debug al cliente
        
        # Verificar capacidad disponible usando el sistema existente
        fecha_str = reservation_data['fecha']
        hay_capacidad, mensaje_error, capacidad_disponible = await verificar_capacidad_disponible(fecha_str, personas, restaurant_config)
        
        if not hay_capacidad:
            # Ofrecer alternativas inteligentes
            mensaje = f"{mensaje_error}\n\n"
            if capacidad_disponible > 0:
                mensaje += f"üí° **Alternativas disponibles:**\n"
                mensaje += f"‚Ä¢ Reducir a {capacidad_disponible} personas\n"
                mensaje += f"‚Ä¢ Elegir otra fecha\n\n"
                mensaje += "¬øQu√© prefieres hacer?"
            else:
                mensaje += "¬øTe gustar√≠a elegir otra fecha?"
            
            send_whatsapp_message(from_number, mensaje, restaurant_config)
            return None  # No enviar mensaje de debug al cliente
        
        # Guardar personas y continuar
        reservation_data['personas'] = personas
        session['reservation_data'] = reservation_data
        session['reservation_state'] = RESERVATION_STATES['ESPERANDO_NOMBRE']
        
        # Guardar sesi√≥n
        restaurant_id = restaurant_config.get('id')
        save_session(from_number, session, restaurant_id)
        
        mensaje = f"¬°Perfecto! Reserva para {personas} persona{'s' if personas > 1 else ''} el {reservation_data['fecha']}. ‚úÖ\n\n"
        mensaje += "¬øCu√°l es tu **nombre completo** para la reserva?"
        
        send_whatsapp_message(from_number, mensaje, restaurant_config)
        return None  # No enviar mensaje de debug al cliente
        
    except Exception as e:
        logger.error(f"‚ùå ERROR in process_persons_input: {str(e)}")
        logger.error(f"Traceback: {traceback.format_exc()}")
        
        # Fallback con mensaje gen√©rico
        mensaje = f"Hubo un problema procesando la cantidad de personas. üë•\n\n"
        mensaje += "Por favor, intenta escribir el n√∫mero de personas nuevamente.\n"
        mensaje += "Ejemplo: 4 personas"
        
        send_whatsapp_message(from_number, mensaje, restaurant_config)
        return None

def process_name_input(from_number, message, restaurant_config, session, reservation_data):
    """Procesa la entrada del nombre"""
    
    nombre = message.strip()
    
    if len(nombre) < 2:
        mensaje = "Por favor, proporciona un nombre v√°lido para la reserva. üë§"
        send_whatsapp_message(from_number, mensaje, restaurant_config)
        return None  # No enviar mensaje de debug al cliente
    
    # Validaci√≥n adicional: evitar nombres que sean solo comandos comunes
    # EXCLUIR "si" y "s√≠" porque pueden ser confirmaciones v√°lidas en otros contextos
    nombre_normalizado = nombre.lower().replace("√°", "a").replace("√©", "e").replace("√≠", "i").replace("√≥", "o").replace("√∫", "u")
    comandos_invalidos = ['ok', 'yes', 'hola', 'menu', 'men√∫', 'reservar', 'no', 'cancelar']
    
    if nombre_normalizado in comandos_invalidos:
        mensaje = f"'{nombre}' parece ser un comando. Por favor, proporciona tu nombre completo para la reserva. üë§\n\n"
        mensaje += "Ejemplo: Juan P√©rez"
        send_whatsapp_message(from_number, mensaje, restaurant_config)
        return None
    
    # Guardar nombre y continuar
    reservation_data['nombre'] = nombre
    session['reservation_data'] = reservation_data
    session['reservation_state'] = RESERVATION_STATES['ESPERANDO_TELEFONO']
    session['nombre_completo'] = nombre  # Tambi√©n lo guardamos en la sesi√≥n general
    
    # Guardar sesi√≥n
    restaurant_id = restaurant_config.get('id')
    save_session(from_number, session, restaurant_id)
    
    mensaje = f"Gracias, {nombre.split()[0]}! üì±\n\n"
    mensaje += "Por favor, ¬øcu√°l es tu **n√∫mero de tel√©fono** de contacto?\n\n"
    mensaje += "(Te recordaremos 24 hs antes sobre la reserva)"
    
    send_whatsapp_message(from_number, mensaje, restaurant_config)
    return None  # No enviar mensaje de debug al cliente

def process_phone_input(from_number, message, restaurant_config, session, reservation_data):
    """Procesa la entrada del tel√©fono"""
    
    logger.info(f"üîç PHONE INPUT: Procesando tel√©fono para {from_number}: '{message}'")
    
    # Extraer n√∫meros del mensaje
    phone_numbers = re.findall(r'[\+]?[\d\s\-\(\)]{8,}', message)
    
    if not phone_numbers:
        mensaje = "Por favor, proporciona un n√∫mero de tel√©fono v√°lido. üì±\n\n"
        mensaje += "Ejemplo: +54 11 1234-5678"
        send_whatsapp_message(from_number, mensaje, restaurant_config)
        logger.info(f"‚ùå PHONE INPUT: N√∫mero inv√°lido para {from_number}")
        return None  # No enviar mensaje de debug al cliente
    
    telefono = phone_numbers[0].strip()
    logger.info(f"‚úÖ PHONE INPUT: Tel√©fono extra√≠do: {telefono}")
    
    # Guardar tel√©fono y continuar al email
    reservation_data['telefono'] = telefono
    session['reservation_data'] = reservation_data
    session['reservation_state'] = RESERVATION_STATES['ESPERANDO_EMAIL']
    
    logger.info(f"üìß PHONE INPUT: Estado cambiado a ESPERANDO_EMAIL para {from_number}")
    logger.info(f"üìä PHONE INPUT: Datos de reserva: {reservation_data}")
    
    # Guardar sesi√≥n
    restaurant_id = restaurant_config.get('id')
    save_session(from_number, session, restaurant_id)
    
    mensaje = f"Perfecto! üìß\n\n"
    mensaje += "Por √∫ltimo, necesitamos tu email, ejemplo: juan@email.com, para enviarte la confirmaci√≥n de la reserva.\n\n"
    mensaje += "Si no encuentras el mail de confirmaci√≥n en tu inbox no te preocupes. Tu reserva est√° confirmada."

    
    send_whatsapp_message(from_number, mensaje, restaurant_config)
    logger.info(f"üì§ PHONE INPUT: Mensaje de email enviado a {from_number}")
    return None  # No enviar mensaje de debug al cliente

def process_email_input(from_number, message, restaurant_config, session, reservation_data):
    """Procesa la entrada del email"""
    
    logger.info(f"üìß EMAIL INPUT: Procesando email para {from_number}: '{message}'")
    logger.info(f"üìä EMAIL INPUT: Datos antes del email: {reservation_data}")
    
    email = message.strip().lower()
    
    # Validar formato de email b√°sico
    email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    
    if not re.match(email_pattern, email):
        logger.info(f"‚ùå EMAIL INPUT: Email inv√°lido para {from_number}: {email}")
        mensaje = "Por favor, proporciona un email v√°lido. üìß\n\n"
        mensaje += "Ejemplo: juan@email.com"
        send_whatsapp_message(from_number, mensaje, restaurant_config)
        return None  # No enviar mensaje de debug al cliente
    
    logger.info(f"‚úÖ EMAIL INPUT: Email v√°lido extra√≠do: {email}")
    
    # Guardar email y mostrar resumen
    reservation_data['email'] = email
    session['reservation_data'] = reservation_data
    session['reservation_state'] = RESERVATION_STATES['ESPERANDO_CONFIRMACION']
    
    logger.info(f"üîÑ EMAIL INPUT: Estado cambiado a ESPERANDO_CONFIRMACION para {from_number}")
    logger.info(f"üìä EMAIL INPUT: Datos finales con email: {reservation_data}")
    
    # Guardar sesi√≥n
    restaurant_id = restaurant_config.get('id')
    save_session(from_number, session, restaurant_id)
    
    logger.info(f"üíæ EMAIL INPUT: Sesi√≥n guardada, mostrando resumen para {from_number}")
    
    return show_reservation_summary(from_number, restaurant_config, session, reservation_data)

def process_initial_confirmation(from_number, message, restaurant_config, session, reservation_data):
    """Procesa la confirmaci√≥n inicial despu√©s del parsing inteligente"""
    
    logger.info(f"ü§ñ INITIAL CONFIRMATION: Procesando confirmaci√≥n inicial para {from_number}: '{message}'")
    
    mensaje_normalizado = message.lower().strip().replace("√°", "a").replace("√©", "e").replace("√≠", "i").replace("√≥", "o").replace("√∫", "u")
    
    # Palabras de confirmaci√≥n m√°s amplias para el parsing inicial
    confirmaciones = ['si', 's√≠', 'yes', 'ok', 'dale', 'perfecto', 'correcto', 'bien', 'confirmo', 'confirmar']
    cancelaciones = ['no', 'cancel', 'cancelar', 'mal', 'incorrecto', 'error']
    
    # Verificar confirmaci√≥n
    if (mensaje_normalizado in confirmaciones or 
        any(conf in mensaje_normalizado.split() for conf in confirmaciones)):
        
        logger.info(f"‚úÖ INITIAL CONFIRMATION: Confirmaci√≥n detectada, pasando a pedir nombre para {from_number}")
        
        # El usuario confirma los datos iniciales, pasar a pedir nombre
        session['reservation_state'] = RESERVATION_STATES['ESPERANDO_NOMBRE'] 
        restaurant_id = restaurant_config.get('id')
        save_session(from_number, session, restaurant_id)
        
        mensaje = "¬°Perfecto! Para completar tu reserva, necesito que me digas tu **nombre completo**. üë§"
        
        send_whatsapp_message(from_number, mensaje, restaurant_config)
        return None  # No enviar mensaje de debug al cliente
        
    # Verificar cancelaci√≥n
    elif (mensaje_normalizado in cancelaciones or 
          any(canc in mensaje_normalizado.split() for canc in cancelaciones)):
        
        logger.info(f"‚ùå INITIAL CONFIRMATION: Cancelaci√≥n detectada para {from_number}")
        return reset_reservation_flow(from_number, restaurant_config, session, "Entendido. Si cambias de opini√≥n, escribe 'reservar' para empezar de nuevo. üòä")
        
    else:
        # Respuesta no clara, pedir aclaraci√≥n
        logger.info(f"‚ùì INITIAL CONFIRMATION: Respuesta no clara para {from_number}: '{message}'")
        
        mensaje = "Por favor, responde **S√ç** si los datos est√°n correctos o **NO** si necesitas cambiarlos. ‚úÖ‚ùå"
        send_whatsapp_message(from_number, mensaje, restaurant_config)
        return None  # No enviar mensaje de debug al cliente

def show_reservation_summary(from_number, restaurant_config, session, reservation_data):
    """Muestra el resumen de la reserva para confirmaci√≥n"""
    restaurant_name = restaurant_config.get('nombre', 'el restaurante')
    
    logger.info(f"üìã SUMMARY: Mostrando resumen para {from_number}")
    logger.info(f"üìä SUMMARY: Datos completos: {reservation_data}")
    
    # Validar que tenemos todos los datos necesarios
    required_fields = ['fecha', 'personas', 'nombre', 'telefono', 'email']
    missing_fields = [field for field in required_fields if not reservation_data.get(field)]
    
    if missing_fields:
        logger.error(f"‚ùå SUMMARY: Campos faltantes para {from_number}: {missing_fields}")
        mensaje = f"Faltan algunos datos para completar la reserva. Vamos a empezar de nuevo.\n\n"
        mensaje += "Por favor, escribe 'reservar' para comenzar."
        send_whatsapp_message(from_number, mensaje, restaurant_config)
        return reset_reservation_flow(from_number, restaurant_config, session, None)
    
    try:
        fecha_obj = datetime.strptime(reservation_data['fecha'], "%d/%m/%Y")
        fecha_formateada = format_date_spanish(fecha_obj)
    except:
        fecha_formateada = reservation_data['fecha']
    
    # FIX: Usar reservation_data['nombre'] en lugar de nombre indefinido
    primer_nombre = reservation_data['nombre'].split()[0]
    mensaje = f"üìã Genial {primer_nombre}! resumen de tu reserva\n\n"
    mensaje += f"üè™ **Restaurante:** {restaurant_name}\n"
    mensaje += f"üìÖ **Fecha:** {fecha_formateada}\n"
    mensaje += f"üë• **Personas:** {reservation_data['personas']}\n"
    mensaje += f"üë§ **Nombre:** {reservation_data['nombre']}\n"
    mensaje += f"üì± **Tel√©fono:** {reservation_data['telefono']}\n"
    mensaje += f"üìß **Email:** {reservation_data['email']}\n\n"
    mensaje += "¬øConfirmas la reserva? ‚úÖ\n\n"
    mensaje += "Responde:\n"
    mensaje += "‚Ä¢ **SI** para confirmar\n"
    mensaje += "‚Ä¢ **NO** para cancelar"
    
    logger.info(f"üì§ SUMMARY: Enviando resumen completo a {from_number}")
    send_whatsapp_message(from_number, mensaje, restaurant_config)
    return None  # No enviar mensaje de debug al cliente

async def process_confirmation(from_number, message, restaurant_config, session, reservation_data):
    """Procesa la confirmaci√≥n final"""
    mensaje_normalizado = message.lower().strip().replace("√°", "a").replace("√©", "e").replace("√≠", "i").replace("√≥", "o").replace("√∫", "u")
    
    # Verificaci√≥n m√°s espec√≠fica para confirmaci√≥n
    # Buscar palabras completas y formas espec√≠ficas de confirmaci√≥n
    palabras_confirmacion = []
    
    # Dividir el mensaje en palabras para an√°lisis m√°s preciso
    palabras = mensaje_normalizado.split()
    
    # Verificar confirmaciones positivas
    if (mensaje_normalizado in ['si', 's√≠', 'yes', 'ok', 'vale', 'dale'] or  # Palabras completas
        any(palabra in ['confirmo', 'confirmar', 'perfecto', 'correcto', 'esta', 'bien'] for palabra in palabras) or  # Palabras espec√≠ficas
        mensaje_normalizado.startswith('si ') or mensaje_normalizado.startswith('s√≠ ') or  # Si seguido de espacio
        mensaje_normalizado.endswith(' si') or mensaje_normalizado.endswith(' s√≠')):  # Si al final
        return await save_reservation(from_number, restaurant_config, session, reservation_data)
    
    # Verificar cancelaciones
    elif (mensaje_normalizado in ['no', 'cancel', 'cancelar'] or
          any(palabra in ['no', 'cancelar', 'cancel', 'cancelo'] for palabra in palabras)):
        return reset_reservation_flow(from_number, restaurant_config, session, "Reserva cancelada. Si cambias de opini√≥n, escribe 'reservar' para empezar de nuevo. üòä")
    
    else:
        mensaje = "Por favor, responde **SI** para confirmar la reserva o **NO** para cancelar. ‚úÖ‚ùå"
        send_whatsapp_message(from_number, mensaje, restaurant_config)
        return None  # No enviar mensaje de debug al cliente

async def save_reservation(from_number, restaurant_config, session, reservation_data):
    """Guarda la reserva en la base de datos"""
    try:
        restaurant_id = restaurant_config.get('id')
        restaurant_name = restaurant_config.get('nombre', 'el restaurante')
        
        logger.info(f"üíæ SAVE: Guardando reserva para {from_number}")
        logger.info(f"üìä SAVE: Datos completos a guardar: {reservation_data}")
        
        # Validar que tenemos el email
        if not reservation_data.get('email'):
            logger.error(f"‚ùå SAVE: Email faltante para {from_number}")
            mensaje = "Error: Email faltante. Por favor, inicia la reserva nuevamente."
            send_whatsapp_message(from_number, mensaje, restaurant_config)
            return reset_reservation_flow(from_number, restaurant_config, session, None)
        
        # Preparar datos para la base de datos
        fecha_obj = datetime.strptime(reservation_data['fecha'], "%d/%m/%Y").date()
        
        reserva_data = {
            'restaurante_id': restaurant_id,
            'fecha': fecha_obj.isoformat(),
            'hora': reservation_data.get('hora', '20:00'),  # Agregar hora requerida
            'personas': reservation_data['personas'],
            'nombre_cliente': reservation_data['nombre'],  # Usar nombre_cliente correcto
            'telefono': reservation_data['telefono'],
            'email': reservation_data['email'],  # CR√çTICO: Asegurar que el email se guarde
            'estado': 'Confirmada',  # Usar formato correcto de estado
            'origen': 'whatsapp',
            'comentarios': f"Reserva desde WhatsApp: {from_number}"  # Incluir info del WhatsApp en comentarios
        }
        
        logger.info(f"üóÉÔ∏è SAVE: Datos para Supabase: {reserva_data}")
        
        # Guardar en Supabase
        supabase = supabase_client
        if supabase:
            result = supabase.table("reservas_prod").insert(reserva_data).execute()
            
            if result.data:
                logger.info(f"‚úÖ SAVE: Reserva guardada exitosamente para {from_number}")
                logger.info(f"üìß SAVE: Email guardado: {reservation_data['email']}")
                
                # üî• CR√çTICO: Enviar confirmaci√≥n por email - ESTO FALTABA!
                try:
                    from services.email_service import enviar_correo_confirmacion
                    logger.info(f"üì§ EMAIL: Intentando enviar confirmaci√≥n a {reservation_data['email']}")
                    
                    # Preparar datos para el email en el formato correcto
                    email_data = {
                        'nombre': reservation_data['nombre'],
                        'email': reservation_data['email'],
                        'telefono': reservation_data['telefono'],
                        'fecha': reservation_data['fecha'],  # Ya est√° en formato DD/MM/YYYY
                        'hora': reservation_data.get('hora', '20:00'),
                        'personas': reservation_data['personas'],
                        'comentarios': f"Reserva desde WhatsApp: {from_number}",
                        'restaurante_id': restaurant_id
                    }
                    
                    email_sent = enviar_correo_confirmacion(email_data, reservation_data['email'], restaurant_config)
                    
                    if email_sent:
                        logger.info(f"‚úÖ EMAIL: Confirmaci√≥n enviada exitosamente a {reservation_data['email']}")
                    else:
                        logger.warning(f"‚ö†Ô∏è EMAIL: No se pudo enviar confirmaci√≥n a {reservation_data['email']}")
                        
                except Exception as email_error:
                    logger.error(f"‚ùå EMAIL: Error enviando confirmaci√≥n: {str(email_error)}")
                    logger.error(f"Traceback: {traceback.format_exc()}")
                
                # Reserva guardada exitosamente
                reset_reservation_flow(from_number, restaurant_config, session, None)
                
                try:
                    fecha_formateada = format_date_spanish(fecha_obj)
                except:
                    fecha_formateada = reservation_data['fecha']
                
                mensaje = f"üéâ **¬°RESERVA CONFIRMADA!**\n\n"
                mensaje += f"‚úÖ Tu reserva en {restaurant_name} ha sido confirmada.\n\n"
                mensaje += f"üìã **Detalles:**\n"
                mensaje += f"üìÖ {fecha_formateada}\n"
                mensaje += f"üë• {reservation_data['personas']} persona{'s' if reservation_data['personas'] > 1 else ''}\n"
                mensaje += f"üë§ {reservation_data['nombre']}\n"
                mensaje += f"üìß Te hemos enviado confirmaci√≥n a : {reservation_data['email']}. Si no lo encuentras revisa la carpeta Spam.\n\n"
                mensaje += f"üì± Te contactaremos al {reservation_data['telefono']} 24 Hs antes para recordarte.\n\n"
                mensaje += f"¬°Esperamos verte pronto en {restaurant_name}! üòä"
                
                send_whatsapp_message(from_number, mensaje, restaurant_config)
                return None  # No enviar mensaje de debug al cliente
            
        # Error al guardar
        mensaje = f"Hubo un problema al confirmar tu reserva. üòî\n\n"
        mensaje += f"Por favor, contacta directamente con {restaurant_name} o intenta nuevamente m√°s tarde."
        
        reset_reservation_flow(from_number, restaurant_config, session, mensaje)
        return None  # No enviar mensaje de debug al cliente
        
    except Exception as e:
        logger.error(f"Error al guardar reserva: {str(e)}")
        return reset_reservation_flow(from_number, restaurant_config, session, "Hubo un error al procesar tu reserva. Por favor, intenta nuevamente.")

def reset_reservation_flow(from_number, restaurant_config, session, mensaje):
    """Resetea el flujo de reserva"""
    session['reservation_state'] = RESERVATION_STATES['INICIO']
    session['reservation_data'] = {}
    
    # Guardar sesi√≥n
    restaurant_id = restaurant_config.get('id')
    save_session(from_number, session, restaurant_id)
    
    if mensaje:
        send_whatsapp_message(from_number, mensaje, restaurant_config)
    
    return None  # No enviar mensaje de debug al cliente

def is_in_reservation_flow(session):
    """Verifica si el usuario est√° en medio de un flujo de reserva"""
    return session.get('reservation_state', RESERVATION_STATES['INICIO']) != RESERVATION_STATES['INICIO']